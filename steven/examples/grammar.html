<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<link href="abc.css" rel="stylesheet" type="text/css">
<title>Grammar Tools in ABC</title>
<!-- Changed by: Steven Pemberton,  1-Nov-1996 -->
</head>
<body bgcolor="#ffff60">
<h1>Grammar Tools in ABC</h1>

<address>
Steven Pemberton<br>
CWI, Amsterdam
</address>

<p>
When I have to work with grammars, I always use ABC to do it. Among
the advantages are that you can do the work interactively, that you
can very quickly build additional tools, and that you have the already
powerful programming environment at your disposal.
</p><p>
What follows is a brief description of some of the tools I use, with
an example. There is no description of ABC here: you can find a quick
description of the language at <a href="http://www.cwi.nl/%7Esteven/abc/">http://www.cwi.nl/~steven/abc/</a>,
with information about ABC (there's a book), and how to get the
implementations (they're free).
</p><p>
Some of what follows is also presented in the book, though at a more
relaxed pace :-).
</p><p>
(For didactic reasons, what is presented here differs in detail from
the distributed code.)

</p><h2>Grammars</h2>

The representation that I use is more or less a direct transcription
of what a grammar is. I use a table whose keys are texts (i.e.
strings) representing the nonterminals of the language, and whose
items are sets of alternatives. Each alternative is a sequence of
texts, representing terminals and nonterminals. So here is a how-to
that displays a grammar in this form:
<pre>	HOW TO DISPLAY grammar:
	   FOR name IN keys grammar:
	      WRITE "`name`: " /
	      FOR alt IN grammar[name]:
		 WRITE "    "
		 FOR symbol IN alt:
		    WRITE symbol, " "
		 WRITE /
</pre>
and as example:
<pre>	&gt;&gt;&gt; DISPLAY sentence
	ADJ:
	    EMPTY
	    clever
	    shy
	BOY:
	    John
	    Kevin
	EMPTY:

	GIRL:
	    Mary
	    Susan
	OBJ:
	    SUBJ
	SENT:
	    SUBJ loves OBJ
	SUBJ:
	    ADJ BOY
	    ADJ GIRL
</pre>
You can generate a random phrase from a grammar with the following:
<pre>	HOW TO GENERATE sym FROM grammar:
	   SELECT:
	      sym in keys grammar: \ Nonterminal
		 FOR new IN choice grammar[sym]:
		    GENERATE new FROM grammar
	      ELSE: \ Terminal symbol
		 WRITE sym, " "

	&gt;&gt;&gt; GENERATE "SENT" FROM sentence
	Susan loves clever John
</pre>
<h2>Sets</h2>
<p>
Here are some necessary functions on sets. Set union:
</p><pre>	HOW TO RETURN set1 with set2: \ Union
	   FOR x IN set2:
	      IF x not.in set1:
		 INSERT x IN set1
	   RETURN set1
</pre>
Set difference:
<pre>	HOW TO RETURN set1 less set2: \ Difference
	   FOR x IN set2:
	      IF x in set1:
		 REMOVE x FROM set1
	   RETURN set1
</pre>
Here is a function that collects all symbols used in the rules of a grammar:
<pre>	HOW TO RETURN used grammar: \Collect all used symbols
	   PUT {} IN all
	   FOR rule IN grammar:
	      FOR alt IN rule:
		 FOR sym IN alt:
		    IF sym not.in all:
		       INSERT sym IN all
	   RETURN all

	&gt;&gt;&gt; WRITE used sentence
	{"ADJ"; "BOY"; "EMPTY"; "GIRL"; "John"; "Kevin"; "Mary";
	 "OBJ"; "SUBJ"; "Susan"; "clever"; "loves"; "shy"}
</pre>
The terminals of the grammar are all the symbols less the nonterminals:
<pre>	&gt;&gt;&gt; WRITE (used sentence) less keys sentence
	{"John"; "Kevin"; "Mary"; "Susan"; "clever"; "loves"; "shy"}
</pre>
and the unused nonterminals (such as the root symbol) are the
nonterminals less the used symbols:
<pre>	&gt;&gt;&gt; WRITE (keys sentence) less used sentence
	{"SENT"}
</pre>
For neater output, the function "listed" converts a set to a text:
<pre>	HOW TO RETURN listed set:
	   PUT "" IN line
	   FOR element IN set:
	      PUT line ^ "`element` " IN line
	   RETURN line

	&gt;&gt;&gt; WRITE listed ((used sentence) less keys sentence)
	John Kevin Mary Susan clever loves shy
</pre>
A useful set is the set of nonterminals that can generate empty. This
is generated by repeatedly doing a pass over the rules that we don't
know yet can generate empty, until we find no more:
<pre>	HOW TO RETURN empties grammar:
	   PUT keys grammar, {} IN to.do, empties
	   WHILE SOME name IN to.do HAS empty.rule:
	      INSERT name IN empties
	      REMOVE name FROM to.do
	   RETURN empties
	empty.rule:
	   REPORT SOME alt IN grammar[name] HAS empty.alt
	empty.alt:
	   REPORT EACH sym IN alt HAS sym in empties

	&gt;&gt;&gt; WRITE listed empties sentence
	ADJ EMPTY
</pre>
<h2>Relations</h2>
<p>
Relations between symbols of the grammar are the essential element of
the grammar tools. A relation is represented as a table whose keys are
symbols, and whose items are sets of symbols.
</p><p>
For instance, if symbol b follows symbol a in some rule, "b" will be
in the set for follows["a"], so you can say, for instance:
</p><pre>	IF "b" in follows["a"]: ....
</pre>
Relations are sparse (i.e. a symbol is not in the keys of the relation
if the set of elements is empty), so we use the following to access a
relation:
<pre>	HOW TO RETURN relation for k: \relation[k] for sparse relations
	   IF k in keys relation:
	      RETURN relation[k]
	   RETURN {}
</pre>
To add an element to a relation, we use this:
<pre>	HOW TO ADD element TO relation FOR thing:
	   IF thing not.in keys relation: \First time
	      PUT {} IN relation[thing]
	   IF element not.in relation[thing]:
	      INSERT element IN relation[thing]
</pre>
though you may prefer
<pre>	HOW TO ADD element TO relation FOR thing:
	   PUT (relation for thing) with {element} IN relation[thing]
</pre>
For instance:
<pre>	&gt;&gt;&gt; ADD "b" TO follows FOR "a"
</pre>
We'll display a relation with:
<pre>	HOW TO SHOW relation:
	   FOR k IN keys relation:
	      WRITE "`k`: ", listed relation[k] /
</pre>
Here are some general functions on relations. The inverse:
<pre>	HOW TO RETURN inverse relation:
	   PUT {} IN inv
	   FOR k IN keys relation:
	      FOR x IN relation[k]:
		 ADD k TO inv FOR x
	   RETURN inv
</pre>
The product of two relations (a P c iff a R1 b and b R2 c):
<pre>	HOW TO RETURN r1 prod r2: \product of relations
	   PUT {} IN prod
	   FOR c IN keys r2:
	      FOR b IN r2[c]:
		 IF b in keys r1:
		    FOR a IN r1[b]:
		       ADD a TO prod FOR c
	   RETURN prod
</pre>
The closure:
<pre>	HOW TO RETURN closure r:
	   FOR i IN keys r:
	      FOR j IN keys r:
		 IF i in r[j]:
		    PUT r[i] with r[j] IN r[j]
	   RETURN r
</pre>
To make a relation reflexive, we use the following. Since relations
are sparse, we also have to pass the set of symbols that it must be
reflexive over:
<pre>	HOW TO RETURN symbols reflexive relation: \make the relation reflexive
	   FOR sym IN symbols:
	      ADD sym TO relation FOR sym
	   RETURN relation
</pre>
<h2>Some Examples of Relations</h2>
<p>
To collect the <em>direct</em> followers for each symbol, we walk along each
alternative, collecting adjacent symbols. There is one catch: in a
rule like:
</p><pre>	SENT: the ADJ PERSON
</pre>
"the" and "ADJ" are adjacent, but if "ADJ" can generate empty, then so
are "the" and "PERSON":
<pre>	HOW TO RETURN followers grammar:
	   PUT {}, empties grammar IN foll, empty
	   FOR rule IN grammar:
	      FOR alt IN rule:
		 TREAT ALT
	   RETURN foll
	TREAT ALT:
	   FOR i IN {1..#alt-1}:
	      PUT alt item i IN this
	      TREAT PART
	TREAT PART:
	   FOR j IN {i+1..#alt}:
	      PUT alt item j IN next
	      ADD next TO foll FOR this
	      IF next not.in empty: QUIT

	&gt;&gt;&gt; SHOW followers sentence
	ADJ: BOY GIRL
	SUBJ: loves
	loves: OBJ
</pre>
To collect the direct starter symbols of each rule, you also have to
deal with symbols that produce empty:
<pre>	HOW TO RETURN heads grammar:
	   PUT {}, empties grammar IN heads, empty
	   FOR name IN keys grammar:
	      FOR alt IN grammar[name]:
		 TREAT ALT
	   RETURN heads
	TREAT ALT:
	   FOR i IN {1..#alt}:
	      PUT alt item i IN head
	      ADD head TO heads FOR name
	      IF head not.in empty: QUIT

	&gt;&gt;&gt; SHOW heads sentence
	ADJ: EMPTY clever shy
	BOY: John Kevin
	GIRL: Mary Susan
	OBJ: SUBJ
	SENT: SUBJ
	SUBJ: ADJ BOY GIRL
</pre>
Similarly for the direct enders:
<pre>	HOW TO RETURN tails grammar:
	   PUT {}, empties grammar IN tails, empty
	   FOR name IN keys grammar:
	      FOR alt IN grammar[name]:
		 TREAT ALT
	   RETURN tails
	TREAT ALT:
	   FOR i' IN {-#alt..-1}:
	      PUT -i' IN i
	      PUT alt item i IN tail
	      ADD tail TO tails FOR name
	      IF tail not.in empty: QUIT
</pre>
The closure of the head relation represents all symbols that can start
a rule, either directly or indirectly:
<pre>	&gt;&gt;&gt; SHOW closure heads sentence
	ADJ: EMPTY clever shy
	BOY: John Kevin
	GIRL: Mary Susan
	OBJ: ADJ BOY EMPTY GIRL John Kevin Mary SUBJ Susan clever shy
	SENT: ADJ BOY EMPTY GIRL John Kevin Mary SUBJ Susan clever shy
	SUBJ: ADJ BOY EMPTY GIRL John Kevin Mary Susan clever shy
</pre>
Symbol b may follow symbol a in a phrase if b follows a in an
alternative, or if B follows A in an alternative and b is in heads*(B)
and a is in tails*(A). This is expressed as the product
<blockquote>
	head* . follow . inverse(tail*).
</blockquote>
<p>
Now we have enough to define a command that prints for each symbol in
an alternative what may follow that symbol at that point:
</p><pre>	HOW TO SHOW LOCAL FOLLOWERS grammar:
	   PUT (used grammar) with keys grammar IN symbols
	   PUT symbols reflexive (closure heads grammar) IN head.star
	   PUT symbols reflexive (closure tails grammar) IN tail.star
	   PUT followers grammar IN follow
	   PUT (head.star prod follow) prod (inverse tail.star) IN deep.follow
	   FOR parent IN keys grammar:
	      FOR alt IN grammar[parent]:
		 TREAT ALT
	TREAT ALT:
	   ANNOUNCE ALT
	   FOR i IN {1..#alt}:
	      TREAT SYM
	TREAT SYM:
	   PUT alt item i IN sym
	   WRITE "    `sym`: ", listed local.follow /
	local.follow:
	   PUT {} IN foll
	   FOR j IN {i+1..#alt}:
	      PUT alt item j IN next
	      PUT foll with (head.star for next) IN foll
	      IF next not.in empty:
		 RETURN foll
	   RETURN foll with (deep.follow for parent)
	ANNOUNCE ALT:
	   WRITE "`parent`: ", listed alt /
</pre>
This prints each alternative separately, followed by each symbol of
the alternative indented one to a line followed by the symbols that
can follow it at that point.
<p>
For example:
</p><pre>	&gt;&gt;&gt; SHOW LOCAL FOLLOWERS sentence
	ADJ: EMPTY
	    EMPTY: BOY GIRL John Kevin Mary Susan
	ADJ: clever
	    clever: BOY GIRL John Kevin Mary Susan
	ADJ: shy
	    shy: BOY GIRL John Kevin Mary Susan
	BOY: John
	    John: loves
	BOY: Kevin
	    Kevin: loves
	EMPTY:
	GIRL: Mary
	    Mary: loves
	GIRL: Susan
	    Susan: loves
	OBJ: SUBJ
	    SUBJ:
	SENT: SUBJ loves OBJ
	    SUBJ: loves
	    loves: ADJ BOY EMPTY GIRL John Kevin Mary OBJ SUBJ Susan clever shy
	    OBJ:
	SUBJ: ADJ BOY
	    ADJ: BOY John Kevin
	    BOY: loves
	SUBJ: ADJ GIRL
	    ADJ: GIRL Mary Susan
	    GIRL: loves
</pre>
Copyright © Steven Pemberton, CWI, Amsterdam, 1991


</body></html>